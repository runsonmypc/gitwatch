#!/bin/bash
watch -t -n 1 -c '
# Icon setup (auto-detect Nerd Fonts)
if [ -n "$GW_ICONS" ] || ls ~/Library/Fonts/*[Nn]erd* /Library/Fonts/*[Nn]erd* 2>/dev/null | grep -q .; then
  ICON_BRANCH=$(printf "\xee\x82\xa0")
  ICON_FILE=$(printf "\xef\x85\x9b")
else
  ICON_BRANCH=""
  ICON_FILE="Δ"
fi

# Branch + sync status
branch=$(git branch --show-current)
upstream=$(git rev-parse --abbrev-ref @{u} 2>/dev/null)
if [ -n "$upstream" ]; then
  counts=$(git rev-list --left-right --count $upstream...HEAD 2>/dev/null)
  behind=$(echo $counts | awk "{print \$1}")
  ahead=$(echo $counts | awk "{print \$2}")
  sync=""
  [ "$ahead" -gt 0 ] && sync="${sync} ↑${ahead}"
  [ "$behind" -gt 0 ] && sync="${sync} ↓${behind}"
  [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ] && sync=" ✓"
  printf "\033[35m${ICON_BRANCH}%s\033[0m%s\n" "$branch" "$sync"
else
  printf "\033[35m${ICON_BRANCH}%s\033[0m \033[2m(no remote)\033[0m\n" "$branch"
fi

echo ""

# Staged changes (without summary)
staged=$(git diff --cached --stat --color)
if [ -n "$staged" ]; then
  printf "\033[94m● staged\033[0m\n"
  echo "$staged" | sed "/files\{0,1\} changed/d"
  echo ""
fi

# Unstaged changes (without summary)
unstaged=$(git diff --stat --color)
if [ -n "$unstaged" ]; then
  printf "\033[36m○ unstaged\033[0m\n"
  echo "$unstaged" | sed "/files\{0,1\} changed/d"
  echo ""
fi

# Untracked files
untracked=$(git status --porcelain -uall | grep "^??" | cut -c4-)
if [ -n "$untracked" ]; then
  printf "\033[33m◌ untracked\033[0m\n"
  cols=$(tput cols 2>/dev/null || echo 80)
  # Reserve space for: " " + name + " | " + number (min 3)
  maxavail=$((cols - 8))
  # Collect file data and find max widths
  data=""
  maxname=0
  maxlines=0
  while read -r file; do
    lines=$(wc -l < "$file" 2>/dev/null | tr -d " ")
    [ -z "$lines" ] && lines=0
    display="$file"
    if [ ${#file} -gt $maxavail ]; then
      # Truncate at directory boundary
      tail="${file: -$((maxavail - 4))}"
      tail="${tail#*/}"
      display=".../$tail"
    fi
    [ ${#display} -gt $maxname ] && maxname=${#display}
    [ $lines -gt $maxlines ] && maxlines=$lines
    data="${data}${display}|${lines}\n"
  done <<< "$untracked"
  # Calculate number width
  numwidth=${#maxlines}
  [ $numwidth -lt 3 ] && numwidth=3
  # Print aligned
  printf "%b" "$data" | while IFS="|" read -r name count; do
    [ -n "$name" ] && printf " %-${maxname}s | \033[33m%${numwidth}d\033[0m\n" "$name" "$count"
  done
  echo ""
fi

# Summary at the bottom
tracked=$(git diff --shortstat 2>/dev/null | awk "{
  files=\$1
  ins=0; del=0
  for(i=1;i<=NF;i++) {
    if(\$i ~ /insertion/) ins=\$(i-1)
    if(\$i ~ /deletion/) del=\$(i-1)
  }
  if(files) printf \"\033[32m+%d\033[0m \033[31m-%d\033[0m \033[2m| %d${ICON_FILE}\033[0m\", ins, del, files
}")
newcount=$(git status --porcelain -uall 2>/dev/null | grep -c "^??")
if [ -n "$tracked" ] && [ "$newcount" -gt 0 ]; then
  printf " %s  \033[2m+%d new\033[0m\n" "$tracked" "$newcount"
elif [ -n "$tracked" ]; then
  printf " %s\n" "$tracked"
elif [ "$newcount" -gt 0 ]; then
  printf " \033[2m+%d new\033[0m\n" "$newcount"
fi

echo ""

# Commits (show enough to reach remote, min 3)
cols=$(tput cols 2>/dev/null || echo 40)
remote_hash=$(git rev-parse @{u} 2>/dev/null)
if [ -n "$remote_hash" ]; then
  ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0)
  count=$((ahead + 1))
  [ $count -lt 3 ] && count=3
else
  count=3
fi
if [ -n "$GW_ICONS" ] || ls ~/Library/Fonts/*[Nn]erd* /Library/Fonts/*[Nn]erd* 2>/dev/null | grep -q .; then
  ICON_CLOUD=$(printf "\xef\x83\x82")
else
  ICON_CLOUD="☁"
fi
head_hash=$(git rev-parse HEAD 2>/dev/null)
git log -$count --format="%H|%s|%cr" | while IFS="|" read -r hash msg time; do
  # Compact time: "3 hours ago" -> "3h"
  time=$(echo "$time" | sed "s/ seconds\\{0,1\\} ago/s/;s/ minutes\\{0,1\\} ago/m/;s/ hours\\{0,1\\} ago/h/;s/ days\\{0,1\\} ago/d/;s/ weeks\\{0,1\\} ago/w/;s/ months\\{0,1\\} ago/mo/;s/ years\\{0,1\\} ago/y/")
  timepart=" ($time)"
  prefix=""
  suffix=""
  suffixwidth=0
  if [ "$hash" = "$head_hash" ]; then
    prefix="*"
  else
    prefix=" "
  fi
  if [ "$hash" = "$remote_hash" ]; then
    suffix="$ICON_CLOUD"
    suffixwidth=1
  fi
  avail=$((cols - ${#timepart} - suffixwidth - 2))
  if [ ${#msg} -gt $avail ]; then
    msg="${msg:0:$avail}"
  fi
  printf "\033[2m%s%s%s%s\033[0m\n" "$prefix" "$msg" "$timepart" "$suffix"
done
'
