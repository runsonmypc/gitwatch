#!/bin/bash
watch -t -n 1 -c '
# Icon setup (auto-detect Nerd Fonts)
if [ -n "$GW_ICONS" ] || ls ~/Library/Fonts/*[Nn]erd* /Library/Fonts/*[Nn]erd* 2>/dev/null | grep -q .; then
  ICON_BRANCH=$(printf "\xee\x82\xa0")
  ICON_FILE=$(printf "\xef\x85\x9b")
else
  ICON_BRANCH=""
  ICON_FILE="Δ"
fi

# Track lines used for dynamic commit count
lines_used=0

# Branch + sync status
branch=$(git branch --show-current)
upstream=$(git rev-parse --abbrev-ref @{u} 2>/dev/null)
if [ -n "$upstream" ]; then
  counts=$(git rev-list --left-right --count $upstream...HEAD 2>/dev/null)
  behind=$(echo $counts | awk "{print \$1}")
  ahead=$(echo $counts | awk "{print \$2}")
  sync=""
  [ "$ahead" -gt 0 ] && sync="${sync} ↑${ahead}"
  [ "$behind" -gt 0 ] && sync="${sync} ↓${behind}"
  [ "$ahead" -eq 0 ] && [ "$behind" -eq 0 ] && sync=" ✓"
  printf "\033[35m${ICON_BRANCH}%s\033[0m%s\n" "$branch" "$sync"
else
  printf "\033[35m${ICON_BRANCH}%s\033[0m \033[2m(no remote)\033[0m\n" "$branch"
fi
lines_used=$((lines_used + 1))

echo ""
lines_used=$((lines_used + 1))

# Staged changes (without summary)
staged=$(git diff --cached --stat --color)
if [ -n "$staged" ]; then
  printf "\033[94m● staged\033[0m\n"
  staged_output=$(echo "$staged" | sed "/files\{0,1\} changed/d")
  echo "$staged_output"
  echo ""
  staged_lines=$(echo "$staged_output" | wc -l | tr -d " ")
  lines_used=$((lines_used + 1 + staged_lines + 1))
fi

# Unstaged changes (without summary)
unstaged=$(git diff --stat --color)
if [ -n "$unstaged" ]; then
  printf "\033[36m○ unstaged\033[0m\n"
  unstaged_output=$(echo "$unstaged" | sed "/files\{0,1\} changed/d")
  echo "$unstaged_output"
  echo ""
  unstaged_lines=$(echo "$unstaged_output" | wc -l | tr -d " ")
  lines_used=$((lines_used + 1 + unstaged_lines + 1))
fi

# Untracked files
untracked=$(git status --porcelain -uall | grep "^??" | cut -c4-)
if [ -n "$untracked" ]; then
  printf "\033[33m◌ untracked\033[0m\n"
  cols=$(tput cols 2>/dev/null || echo 80)
  # Reserve space for: " " + name + " | " + number (min 3)
  maxavail=$((cols - 8))
  # Collect file data and find max widths
  data=""
  maxname=0
  maxlines=0
  untracked_count=0
  while read -r file; do
    lines=$(wc -l < "$file" 2>/dev/null | tr -d " ")
    [ -z "$lines" ] && lines=0
    display="$file"
    if [ ${#file} -gt $maxavail ]; then
      # Truncate at directory boundary
      tail="${file: -$((maxavail - 4))}"
      tail="${tail#*/}"
      display=".../$tail"
    fi
    [ ${#display} -gt $maxname ] && maxname=${#display}
    [ $lines -gt $maxlines ] && maxlines=$lines
    data="${data}${display}|${lines}\n"
    untracked_count=$((untracked_count + 1))
  done <<< "$untracked"
  # Calculate number width
  numwidth=${#maxlines}
  [ $numwidth -lt 3 ] && numwidth=3
  # Print aligned
  printf "%b" "$data" | while IFS="|" read -r name count; do
    [ -n "$name" ] && printf " %-${maxname}s | \033[33m%${numwidth}d\033[0m\n" "$name" "$count"
  done
  echo ""
  lines_used=$((lines_used + 1 + untracked_count + 1))
fi

# Summary at the bottom
tracked=$(git diff --shortstat 2>/dev/null | awk "{
  files=\$1
  ins=0; del=0
  for(i=1;i<=NF;i++) {
    if(\$i ~ /insertion/) ins=\$(i-1)
    if(\$i ~ /deletion/) del=\$(i-1)
  }
  if(files) printf \"\033[32m+%d\033[0m \033[31m-%d\033[0m \033[2m| %d${ICON_FILE}\033[0m\", ins, del, files
}")
newcount=$(git status --porcelain -uall 2>/dev/null | grep -c "^??")
if [ -n "$tracked" ] && [ "$newcount" -gt 0 ]; then
  printf " %s  \033[2m+%d new\033[0m\n" "$tracked" "$newcount"
  lines_used=$((lines_used + 1))
elif [ -n "$tracked" ]; then
  printf " %s\n" "$tracked"
  lines_used=$((lines_used + 1))
elif [ "$newcount" -gt 0 ]; then
  printf " \033[2m+%d new\033[0m\n" "$newcount"
  lines_used=$((lines_used + 1))
fi

echo ""
lines_used=$((lines_used + 1))

# Commits (fill remaining vertical space)
cols=$(tput cols 2>/dev/null || echo 40)
rows=$(tput lines 2>/dev/null || echo 24)
remote_hash=$(git rev-parse @{u} 2>/dev/null)
avail_rows=$((rows - lines_used))
[ $avail_rows -lt 1 ] && avail_rows=1
if [ -n "$remote_hash" ]; then
  ahead=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo 0)
  min_count=$((ahead + 1))
  [ $min_count -lt 3 ] && min_count=3
  count=$avail_rows
  [ $count -lt $min_count ] && count=$min_count
else
  count=$avail_rows
  [ $count -lt 3 ] && count=3
fi
if [ -n "$GW_ICONS" ] || ls ~/Library/Fonts/*[Nn]erd* /Library/Fonts/*[Nn]erd* 2>/dev/null | grep -q .; then
  ICON_CLOUD=$(printf "\xef\x83\x82")
  ICON_HEAD=$(printf "\xef\x86\x92")      # fa-dot-circle-o (you are here)
  # Conventional commit type icons
  ICON_FEAT=$(printf "\xef\x84\xb5")      # fa-rocket
  ICON_FIX=$(printf "\xef\x82\xad")       # fa-wrench
  ICON_DOCS=$(printf "\xef\x80\xad")      # fa-book
  ICON_STYLE=$(printf "\xef\x87\xbc")     # fa-paint-brush
  ICON_REFACTOR=$(printf "\xef\x80\xa1")  # fa-refresh
  ICON_TEST=$(printf "\xef\x83\x83")      # fa-flask
  ICON_CHORE=$(printf "\xef\x80\x93")     # fa-cog
  ICON_PERF=$(printf "\xef\x83\xa7")      # fa-bolt
  ICON_CI=$(printf "\xef\x82\x85")        # fa-cogs
  ICON_BUILD=$(printf "\xef\x86\xb2")     # fa-cube
  ICON_REVERT=$(printf "\xef\x83\xa2")    # fa-undo
  ICON_SKILL=$(printf "\xef\x83\xaa")     # fa-clipboard
  ICON_CASE=$(printf "\xef\x82\xb1")      # fa-briefcase
else
  ICON_CLOUD="☁"
  ICON_HEAD="*"
fi
head_hash=$(git rev-parse HEAD 2>/dev/null)
git log -$count --format="%H|%s|%cr" | while IFS="|" read -r hash msg time; do
  # Transform conventional commits to icons (Nerd Fonts only)
  if [ -n "$ICON_FEAT" ]; then
    # Scoped: "type(scope): msg" → "icon scope: msg"
    msg=$(echo "$msg" | sed \
      -e "s/^feat(\([^)]*\)): /$ICON_FEAT \1: /" \
      -e "s/^fix(\([^)]*\)): /$ICON_FIX \1: /" \
      -e "s/^docs(\([^)]*\)): /$ICON_DOCS \1: /" \
      -e "s/^style(\([^)]*\)): /$ICON_STYLE \1: /" \
      -e "s/^refactor(\([^)]*\)): /$ICON_REFACTOR \1: /" \
      -e "s/^test(\([^)]*\)): /$ICON_TEST \1: /" \
      -e "s/^chore(\([^)]*\)): /$ICON_CHORE \1: /" \
      -e "s/^perf(\([^)]*\)): /$ICON_PERF \1: /" \
      -e "s/^ci(\([^)]*\)): /$ICON_CI \1: /" \
      -e "s/^build(\([^)]*\)): /$ICON_BUILD \1: /" \
      -e "s/^revert(\([^)]*\)): /$ICON_REVERT \1: /" \
      -e "s/^skill(\([^)]*\)): /$ICON_SKILL \1: /" \
      -e "s/^case(\([^)]*\)): /$ICON_CASE \1: /")
    # Scopeless: "type: msg" → "icon msg"
    msg=$(echo "$msg" | sed \
      -e "s/^feat: /$ICON_FEAT /" \
      -e "s/^fix: /$ICON_FIX /" \
      -e "s/^docs: /$ICON_DOCS /" \
      -e "s/^style: /$ICON_STYLE /" \
      -e "s/^refactor: /$ICON_REFACTOR /" \
      -e "s/^test: /$ICON_TEST /" \
      -e "s/^chore: /$ICON_CHORE /" \
      -e "s/^perf: /$ICON_PERF /" \
      -e "s/^ci: /$ICON_CI /" \
      -e "s/^build: /$ICON_BUILD /" \
      -e "s/^revert: /$ICON_REVERT /" \
      -e "s/^skill: /$ICON_SKILL /" \
      -e "s/^case: /$ICON_CASE /")
  fi
  # Compact time: "3 hours ago" -> "3h"
  time=$(echo "$time" | sed "s/ seconds\\{0,1\\} ago/s/;s/ minutes\\{0,1\\} ago/m/;s/ hours\\{0,1\\} ago/h/;s/ days\\{0,1\\} ago/d/;s/ weeks\\{0,1\\} ago/w/;s/ months\\{0,1\\} ago/mo/;s/ years\\{0,1\\} ago/y/")
  timepart="($time)"
  suffix=""
  suffixwidth=0
  if [ "$hash" = "$remote_hash" ]; then
    suffix="$ICON_CLOUD"
    suffixwidth=1
  fi
  if [ "$hash" = "$head_hash" ]; then
    suffix="${suffix}${ICON_HEAD}"
    suffixwidth=$((suffixwidth + 1))
  fi
  avail=$((cols - ${#timepart} - suffixwidth - 1))
  if [ ${#msg} -gt $avail ]; then
    msg="${msg:0:$avail}"
  fi
  printf "\033[2m%s%s%s\033[0m\n" "$msg" "$timepart" "$suffix"
done
'
